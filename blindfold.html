<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css">
  <link rel="stylesheet" href="css/style.css">
  <script src="//ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="js/roofpig_and_three.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/vue"></script>
  <style>
    .center {
      text-align: center;
      margin-left: auto;
      margin-right: auto;
    }
    td div {
      text-align: center;
      margin-left: auto;
      margin-right: auto;
    }
    th {
      text-align: center;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
  <title>Rubik</title>
</head>
<body>

<div id="app">
  <form class="pure-form pure-form-aligned">
  <fieldset>
    <div class="pure-control-group">
      <label for="">Corner Position</label>
      <input type="text" v-model="corner_pos">
    </div>
    <div class="pure-control-group">
      <label for="">Corner Face</label>
      <input type="text" v-model="corner_color">
    </div>
    <div class="pure-control-group">
      <label for="">Edge Position</label>
      <input type="text" v-model="edge_pos">
    </div>
    <div class="pure-control-group">
      <label for="">Edge Face</label>
      <input type="text" v-model="edge_color">
    </div>
    <div class="pure-controls">
      <button class="pure-button pure-button-primary" v-on:click="renderCube">Render!</button>
    </div>
  </fieldset>
  </form>

  <table class="pure-table">
    <thead><tr><th>U-F-R</th><th>U-B-L</th></tr></thead>
    <tbody>
      <tr>
        <td><div id="front" class="cube"></div></td>
        <td><div id="back" class="cube"></div></td>
      </tr>
    </tbody>
  </table>

  <pre>{{ cubeString }}</pre>
</div>

  <script>
  $(document).ready(function() {
    function jsUcfirst(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function makeCubeExpr(pairs) {
      return pairs.map(pair =>
          [jsUcfirst(pair.color), jsUcfirst(pair.pos)].join(":")).join(" ");
    }

    function permutation(str, i) {
      return [str.slice(i, str.length), str.slice(0, i)].join("");
    }

    function make_piece(pos, color, order) {
      order = (order == undefined) ? 0 : order;
      color = permutation((color == undefined) ? pos : color, order);
      var pairs = pos.split("").map((_, i) =>
          ({pos: permutation(pos, i), color: color[i]}));
      return makeCubeExpr(pairs);
    }

    function decode(str) {
      if (str == '0') {
        return 9;
      } else if (str == 'A') {
        return 10;
      } else if (str == 'B') {
        return 11;
      } else {
        return str.charCodeAt(0) - '1'.charCodeAt(0);
      }
    }

    function encode(index) {
      if (index == 9) {
        return '0';
      } else if (index == 10) {
        return 'A';
      } else if (index == 11) {
        return 'B';
      } else {
        return String.fromCharCode(index + '1'.charCodeAt(0));
      }
    }

    function cubePiece(piece_array, i, j, order) {
      j = (j == undefined) ? i : j;
      var pos = piece_array[decode(i)];
      var color = piece_array[decode(j)];
      order = (order == undefined) ? 0 : order;
      color = permutation(color, order);
      var pairs = pos.split("").map((_, i) =>
          ({pos: permutation(pos, i), color: color[i]}));
      return makeCubeExpr(pairs);
    }

    function pos2Mapping(pos) {
      var mapping = {};
      var circles = pos.split("-");
      var startIndex = 0;
      for (var c=0; c<circles.length; c++) {
        var circle = circles[c];
        for (var i=0; i<circle.length-1; i++) {
          mapping[pos[startIndex+i]] = pos[startIndex+i+1];
        }
        if (circle.length > 0) {
          mapping[pos[startIndex+circle.length-1]] = pos[startIndex];
        }
        startIndex += circle.length + 1;
      }
      return mapping;
    }

    function state2Piece(state, pieces) {
      var result = [];
      var mapping = pos2Mapping(state.pos);
      for (var c=0; c<pieces.length; c++) {
        var pos = encode(c);
        var mapped_pos = (pos in mapping) ? mapping[pos] : pos;
        var order = (c < state.color.length) ? state.color[c] : 0;
        console.log(pos, '->', mapped_pos, ':', order);
        result.push(cubePiece(pieces, pos, mapped_pos, order));
      }
      return result;
    }

    const CENTERS = [
      "u", "d", "f", "b", "l", "r", // 6 center pieces
    ];
    const CORNERS = [
      "ufl", "ulb", "ubr", "urf", // top corner pieces
      "dlf", "dbl", "drb", "dfr", // bottom corner pieces
    ];
    const EDGES = [
      "uf", "ul", "ub", "ur", // top edge pieces
      "df", "dl", "db", "dr", // bottom edge pieces
      "fr", "fl", "bl", "br", // middle edge pieces
    ];

    function centers() {
      return makeCubeExpr(CENTERS.map(c => ({pos: c, color: c})));
    }

    function cube2Expr(cube) {
      return [centers()].concat(
          state2Piece(cube.corner, CORNERS),
          state2Piece(cube.edge, EDGES)).join(" ");
    }

    function formatCube(cube) {
      return JSON.stringify(cube, null, ' ');
    }

    function createCube(expr, cube, parent_div, is_back) {
      if (cube != null) {
        cube.remove();
      }
      expr = "solved=*|tweaks=" + expr;
      if (is_back) {
        expr = "pov=Ubl|" + expr;
      }
      return CubeAnimation.create_in_dom(parent_div, expr, "class='width150 myroofpig'");
    }

    var cube = new Vue({
      el: '#app',
      data: function() {
        return {
          corner_pos: "1375468",
          corner_color: "12001002",
          edge_pos: "10753249B-6A8",
          edge_color: "100000000100",
          front_cube: null,
          back_cube: null,
        }
      },
      computed: {
        cube: function() {
          return {
            corner: { pos: this.corner_pos, color: this.corner_color },
            edge: { pos: this.edge_pos, color: this.edge_color },
          }
        },
        cubeString: function() {
          return formatCube(this.cube);
        }
      },
      mounted: function() {
        this.renderCube();
      },
      methods: {
        renderCube: function() {
          var expr = cube2Expr(this.cube);
          this.front_cube = createCube(expr, this.front_cube, "#front");
          this.back_cube = createCube(expr, this.back_cube, "#back", true);
        }
      }
    });
  });
  </script>
</body>
</html>
