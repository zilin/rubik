<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,300italic,700,700italic">
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css">
  <!--[if lte IE 8]>
   <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
   <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/grids-responsive-min.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="css/style.css">
  <script src="//ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="js/roofpig_and_three.min.js"></script>
  <!--script src="//cdn.jsdelivr.net/npm/vue"></script-->
  <script src="//cdn.jsdelivr.net/vue/1.0.21/vue.js"></script>
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      font-size: 16px;
      margin-left: 5px;
      margin-right: 5px;
    }
    .center {
      text-align: center;
      margin-left: auto;
      margin-right: auto;
    }
    td div {
      text-align: center;
      margin-left: auto;
      margin-right: auto;
    }
    th {
      text-align: center;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
  <title>Rubik</title>
</head>
<body>

<div id="app">
  <div class="pure-form pure-form-aligned">
  <fieldset>
    <!--div class="pure-g">
      <div class="pure-u-1 pure-u-md-1-4">
        <label for="">Corner Pos</label>
        <input type="text" v-model="corner_pos" size="12">
      </div>
      <div class="pure-u-1 pure-u-md-1-4">
        <label for="">Corner Face</label>
        <input type="text" v-model="corner_color" maxlength="8" size="12">
      </div>
      <div class="pure-u-1 pure-u-md-1-4">
        <label for="">Edge Pos</label>
        <input type="text" v-model="edge_pos" size="12">
      </div>
      <div class="pure-u-1 pure-u-md-1-4">
        <label for="">Edge Face</label>
        <input type="text" v-model="edge_color" maxlength="12" size="12">
      </div>
    </div-->
    <div class="pure-control-group">
      <label for="">Corner Pos</label>
      <input type="text" v-model="corner_pos" size="15">
    </div>
    <div class="pure-control-group">
      <label for="">Corner Face</label>
      <input type="text" v-model="corner_color" maxlength="8" size="15">
    </div>
    <div class="pure-control-group">
      <label for="">Edge Pos</label>
      <input type="text" v-model="edge_pos" size="15">
    </div>
    <div class="pure-control-group">
      <label for="">Edge Face</label>
      <input type="text" v-model="edge_color" maxlength="12" size="15">
    </div>
    <!--div class="pure-controls">
      <button class="pure-button pure-button-primary" v-on:click="renderCube">Render!</button>
    </div-->
  </fieldset>
  </div>

  <table class="pure-table">
    <thead><tr><th>U-F-R</th><th>U-B-L</th></tr></thead>
    <tbody>
      <tr>
        <td><div id="front" class="cube"></div></td>
        <td><div id="back" class="cube"></div></td>
      </tr>
    </tbody>
  </table>

  <h3>Step 1: {{ corner_color }}</h3>
  <p>Using the following "Formula 1" and "Formula 2"
  to flip corner piece "2" counter-clockwisely and clockwisely.</p>
  <table class="pure-table">
    <thead><tr><th>Formula 1</th><th>Formula 2</th></tr></thead>
    <tbody>
      <tr>
        <td><div class="width150 roofpig" data-config="alg=R U R' U R U2 R' L' U' L U' L' U2 L|flags=showalg|tweaks=X:Lub"></div></td>
        <td><div class="width150 roofpig" data-config="alg=L' U2 L U L' U L R U2 R' U' R U' R'|flags=showalg|tweaks=X:Bul"></div></td>
      </tr>
    </tbody>
  </table>
  <p>Move corner piece to position "2" using the following rules:
  <table class="pure-table pure-table-striped">
    <thead><tr><th>Position</th><th>Move</th></tr></thead>
    <tbody>
      <tr><td>3</td><td>R2(3->8), D+(8->7), B2(7->2)</td></tr>
      <tr><td>4,5,6,7,8</td><td>*->7, B2(7->2)</td></tr>
    </tbody>
  </table>

  <h3>Step 2: {{ edge_color }}</h3>
  <p>Using the following "Formula 3" to flip edge piece "3".</p>
  <table class="pure-table">
    <thead><tr><th>Formula 3</th></tr></thead>
    <tbody>
      <tr>
        <td><div class="width150 roofpig" data-config="alg=M' U M' U M' U2 M U M U M U2|flags=showalg|tweaks=X:Bu"></div></td>
      </tr>
    </tbody>
  </table>
  <p>Move edge piece to position "3" using the following rules:
  <table class="pure-table pure-table-striped">
    <thead><tr><th>Position</th><th>Move</th></tr></thead>
    <tbody>
      <tr><td>2,0,A</td><td>*->A, B-(A->3)</td></tr>
      <tr><td>4,5,6,7,8</td><td>*->7, B2(7->3)</td></tr>
      <tr><td>9,B</td><td>*->B, B+(B->3)</td></tr>
    </tbody>
  </table>

  <h3>Step 3: {{ corner_pos }}</h3>
  <p>Using the following "Formula 4" to swap corner piece "1" and "2".</p>
  <table class="pure-table">
    <thead><tr><th>Formula 4</th></tr></thead>
    <tbody>
      <tr>
        <td><div class="width150 roofpig" data-config="alg=R U' L' U R' U2 L U' L' U2 L|flags=showalg"></div></td>
      </tr>
    </tbody>
  </table>
  <p>Using the same rule in step 1 to move corner piece to position "2".

  <h3>Step 4: {{ edge_pos }}</h3>
  <p>Using "Formula 4" to swap edge piece "1" and "2".</p>
  <p>Move edge piece to position "2" using the following rules:
  <table class="pure-table pure-table-striped">
    <thead><tr><th>Position</th><th>Move</th></tr></thead>
    <tbody>
      <tr><td>3</td><td>MR(3->7), D+(7->6), MR-, MF(6-2)</td></tr>
      <tr><td>4</td><td>R2(4->8), MF2(8->2)</td></tr>
      <tr><td>5,6,7,8</td><td>*->8, MF2(8->2)</td></tr>
      <tr><td>0,B</td><td>[MU2(0->B)], R+(B->8), MF2(8->2)</td></tr>
      <tr><td>9,A</td><td>[MU2(A->9)], R-(9->8), MF2(8->2)</td></tr>
    </tbody>
  </table>

</div>

  <script>
  $(document).ready(function() {
    function jsUcfirst(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function makeCubeExpr(pairs) {
      return pairs.map(pair =>
          [jsUcfirst(pair.color), jsUcfirst(pair.pos)].join(":")).join(" ");
    }

    function permutation(str, i) {
      return [str.slice(i, str.length), str.slice(0, i)].join("");
    }

    function make_piece(pos, color, order) {
      order = (order == undefined) ? 0 : order;
      color = permutation((color == undefined) ? pos : color, order);
      var pairs = pos.split("").map((_, i) =>
          ({pos: permutation(pos, i), color: color[i]}));
      return makeCubeExpr(pairs);
    }

    function decode(str) {
      if (str == '0') {
        return 9;
      } else if (str == 'A') {
        return 10;
      } else if (str == 'B') {
        return 11;
      } else {
        return str.charCodeAt(0) - '1'.charCodeAt(0);
      }
    }

    function encode(index) {
      if (index == 9) {
        return '0';
      } else if (index == 10) {
        return 'A';
      } else if (index == 11) {
        return 'B';
      } else {
        return String.fromCharCode(index + '1'.charCodeAt(0));
      }
    }

    function cubePiece(piece_array, i, j, order) {
      j = (j == undefined) ? i : j;
      var pos = piece_array[decode(i)];
      var color = piece_array[decode(j)];
      order = (order == undefined) ? 0 : order;
      color = permutation(color, order);
      var pairs = pos.split("").map((_, i) =>
          ({pos: permutation(pos, i), color: color[i]}));
      return makeCubeExpr(pairs);
    }

    function pos2Mapping(pos) {
      var mapping = {};
      var circles = pos.split("-");
      var startIndex = 0;
      for (var c=0; c<circles.length; c++) {
        var circle = circles[c];
        for (var i=0; i<circle.length-1; i++) {
          mapping[pos[startIndex+i]] = pos[startIndex+i+1];
        }
        if (circle.length > 0) {
          mapping[pos[startIndex+circle.length-1]] = pos[startIndex];
        }
        startIndex += circle.length + 1;
      }
      return mapping;
    }

    function state2Piece(state, pieces) {
      var result = [];
      var mapping = pos2Mapping(state.pos);
      for (var c=0; c<pieces.length; c++) {
        var pos = encode(c);
        var mapped_pos = (pos in mapping) ? mapping[pos] : pos;
        var order = (c < state.color.length) ? state.color[c] : 0;
        console.log(pos, '->', mapped_pos, ':', order);
        result.push(cubePiece(pieces, pos, mapped_pos, order));
      }
      return result;
    }

    const CENTERS = [
      "u", "d", "f", "b", "l", "r", // 6 center pieces
    ];
    const CORNERS = [
      "ufl", "ulb", "ubr", "urf", // top corner pieces
      "dlf", "dbl", "drb", "dfr", // bottom corner pieces
    ];
    const EDGES = [
      "uf", "ul", "ub", "ur", // top edge pieces
      "df", "dl", "db", "dr", // bottom edge pieces
      "fr", "fl", "bl", "br", // middle edge pieces
    ];

    function centers() {
      return makeCubeExpr(CENTERS.map(c => ({pos: c, color: c})));
    }

    function cube2Expr(cube) {
      return [centers()].concat(
          state2Piece(cube.corner, CORNERS),
          state2Piece(cube.edge, EDGES)).join(" ");
    }

    function formatCube(cube) {
      return JSON.stringify(cube, null, ' ');
    }

    function createCube(expr, cube, parent_div, is_back) {
      if (cube != null) {
        cube.remove();
      }
      expr = "solved=*|tweaks=" + expr;
      if (is_back) {
        expr = "pov=Ubl|" + expr;
      }
      return CubeAnimation.create_in_dom(parent_div, expr, "class='width150 myroofpig'");
    }

    var cube = new Vue({
      el: '#app',
      data: function() {
        return {
          corner_pos: "",
          corner_color: "",
          edge_pos: "",
          edge_color: "",
          front_cube: null,
          back_cube: null,
        }
      },
      computed: {
        cube: function() {
          return {
            corner: { pos: this.corner_pos, color: this.corner_color },
            edge: { pos: this.edge_pos, color: this.edge_color },
          }
        },
        cubeString: function() {
          return formatCube(this.cube);
        }
      },
      watch: {
        cube: function(val) {
          this.renderCube();
        }
      },
      ready: function() {
        this.renderCube();
      },
      methods: {
        renderCube: function() {
          var expr = cube2Expr(this.cube);
          this.front_cube = createCube(expr, this.front_cube, "#front");
          this.back_cube = createCube(expr, this.back_cube, "#back", true);
        }
      }
    });
  });
  </script>
</body>
</html>
